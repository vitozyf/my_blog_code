---
title: nodeJS
date: 2016-08-22 23:14:59
tags: 
-  "node"
categories: 
-  "后台"
---

## 同步读取文件

- 注意：使用同步方法的时候，如果报错了，会立即将错误消息抛出，同时终止后续代码的执行。
- 在同步代码中，为了保证程序的健壮性（轻易不出错，出错了也不会影响后续代码的执行；将来后续维护更方便），一定要在可能出现错误的地方使用try ...catch...捕获错误。

## 异步读取文件

- 注意：在异步的操作中，永远无法使用try catch捕获错误，如果想要捕获错误，只能检查err是否为null
- 在异步方法中报错，不会影响后续代码的执行！

## 模块

### Node 中如何实现模块化

在Node中通过三个东西实现模块化：

- module：表示一个模块，在Node中，最常见的模块，就是一个个的JS文件！
- require：作用是加载其他模块用的；在一个JS文件中，如何引用其他JS文件中的成员呢？就是用require
- exports：在Node的模块中，如果这个模块需要向外暴露一些成员，供其他JS模块使用，那么，需要使用exports向外暴露这些成员！

> Node 中的模块化，主要解决的JS文件之间的相互依赖关系！

### Node 模块

- node中的模块化基于commonJS：最显著的特点，所有依赖性都是同步加载的！！
- `commonJS`由于是一个同步加载规范，所以不适合浏览器端使用；浏览器端需要使用异步的模块加载机智
- 浏览器端的AMD、CMD

#### 第三方模块

- 什么是第三方模块：出了官方提供的好用的核心模块之外，我们程序员发现，还有一些使用也很频繁的代码和方法，一些牛逼的团体、个人、公司，开发出了好用的模块，通过NPM官网，托管出去，供其他人下载使用的这些模块；统称为第三方模块；
- 如何使用第三方模块
  －　通过moment这个第三方模块，来介绍如何使用一个第三方模块；
- 第三方模块的使用方式：

1. 先使用npm下载这个模块！【注意：在安装第三方模块的时候，安装的名字，就是你在require时候导入的名字】
2. 使用require导入这个第三方模块！
3. 通过官方文档，试着去使用这个第三方模块！
4. 注意：无论是核心模块、还是第三方模块，都是通过 `标识符名称`来引用这个模块的！

#### 用户模块

- 什么是用户模块：程序员自己定义的JS文件，统统数据用户模块！
- 用户模块向外导出成员的两种方式：


- 第一种方式：使用global对象，相当于浏览器中的window对象
  - 1. 全局变量污染，
  - 1. 不知道成员是从哪个模块中暴露 出去的
- 推荐Node提供的exports

### Node中的global对象

- Node中的global相当于浏览器中的window；是一个全局对象。
- 可以使用global对象向全局挂在属性和方法。调用时global可以省略。
- 虽然global对象能够向外暴露成员，但是问题还是比较严重的
  1. 全局变量污染，将来在global上可能会挂载很多属性，同时这些属性存在覆盖问题
  2. 不知道成员是从哪个模块中暴露出来的
- 如果想向外暴露成员，不推荐使用global，推荐使用exports

### exports

- 使用

  ```javascript
  exports.address="深圳";
  exports.sayHello = function(){}
  //调用时用返回值接收，调用内部方法或属性
  ```

- 1. 使用exports向外暴露的成员是一个对象，不会造成全局变量污染。

#### exports和module.exports向外导出成员时的区别

- 初始时module.exports和exports全等，指向的是同一个对象。


- module.exports可以通过`.`追加属性或方法，或者直接赋值对象，暴露出去的都是对象。
- exports只能通过`.`给对象追加属性或方法，不能直接赋值对象，否则暴露出去的是空对象。
  - 原因：在一个module中最终向外暴露的成员，以module.exports指向的成员为准。初始化时两个全等，指向同一个对象，但是给exports直接赋值对象后，将和module.exports指向的对象不再相同，向外暴露的是module.exports初始指向的空对象。
- 在一个模块中，不要混合使用。

### 模块加载原则

1. 模块优先从缓存中加载
   - 好处：加快了程序的运行速度
2. 加载核心模块：优先从缓存中加载，如果缓存中没有再去执行加载
3. 自己的模块：优先从缓存中加载，如果缓存中没有再去执行加载
   - 用户模块的加载规则：require("index")
     1. 如果不写后缀名，则严格按照给定的文件名去查找模块并加载执行。
     2. 查找顺序 index >  index.js > index.json >  index.node
4. 第三方模块查找规则
   1. 首先查看项目根目录中有没有"node_modules"文件夹
   2. 查找"node_modules"文件夹中有没有第三方模块名称一致的文件夹
   3. 在模块对应的文件夹中，查找有没有`package.json`这个文件
   4. 在`package.json`文件中查找有没有`main`属性
   5. 如果有`main`属性，并且`main`属性指向的路径存在，那么就尝试加载路径指向的文件
   6. 如果`package.json`文件中没有`main`属性，或者`main`属性指向的路径不存在，或者没有`package.json`文件，那么node尝试加载该模块根目录中的`index`相关文件：`index.js`>`index.json`>`index.node`
   7. 如果在`node_modules`文件夹中找不到对应的模块文件夹，或者在项目根目录中根本没有`node_modules`文件夹，则像上一层文件夹中去查找，查找规则同上。
   8. 如果上一层目录中也没有查找到，则再向上翻一层去查找，直到找到当前项目所在的盘符根目录位置。
   9. 如果找到了盘符根目录还找不到，则报错`cannot find module ***`

### 注意点

- 注意：只有用户模块使用路径标识符来引用的；其他的想核心模块和第三方模块都是用标识符名称来引用的。
- 注意：当使用require来引用一个其他模块的时候，那么会编译执行被引用模块中的JS代码

### 只安装部署依赖，不安装开发工具

- npm i --production

## art-template

1. 服务器端渲染
   - Node服务器先读取模板页面，再获取要渲染的数据，然后直接在服务器把完整的页面渲染拼接好，然后通过网络一次性把结果发送给浏览器去显示。（通过服务器渲染，在网络中传输的是一个真正的页面）
   - 优点：请求次数少，速度快，对SEO友好。
   - 缺点：服务器渲染压力大（在后端可以通过缓存机制去解决）
2. 客户端渲染
   - 特点：先访问服务器获取到的模板页面，然后再通过Ajax获取要渲染的数据，拿到这两者后再在客户端调用模板引擎，渲染得到模板字符串，然后通过JS的方式把结果展示到页面上。（网络传输的时候第一次传输的是模板页，第二次传输的是数据）
   - 优点：减轻了服务器端的渲染压力
   - 缺点：请求次数多，用户体验可能没有服务器端渲染好（白屏效果）；对SEO不友好。
3. 需要对SEO友好的情况下在客户端渲染

## 使用`nodemon`来自动重启Node服务

1. 运行`npm i nodemon -g`全局安装模块
2. 使用方式 和 `node` 完全一样：

- `node 要执行文件的路径`
- `nodemon 要执行文件的路径`

## 相关文章

1. [art-template 官方文档](https://aui.github.io/art-template/)
2. [ES6 - 模板字符串](http://www.infoq.com/cn/articles/es6-in-depth-template-string)
3. [js中的数组对象排序](http://www.cnblogs.com/xljzlw/p/3694861.html)
4. [i5ting/tocmd.npm 将MD转换为HTML](https://github.com/i5ting/tocmd.npm)